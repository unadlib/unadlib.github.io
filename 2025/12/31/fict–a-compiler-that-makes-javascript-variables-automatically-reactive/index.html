


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>Fict â€“ A compiler that makes JavaScript variables automatically reactiveunadlib&#39;s Notes</title>
  <script>
    (function() {
      try {
        var themeKey = 'attraction-theme';
        var savedTheme = localStorage.getItem(themeKey);
        var prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        var theme = savedTheme || (prefersDark ? 'dark' : 'light');
        document.documentElement.setAttribute('data-theme', theme);
      } catch (e) {
        document.documentElement.setAttribute('data-theme', 'light');
      }
    })();
  </script>
  <style type="text/css">
    body, html {
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
      font-size: 18px;
      line-height: 1.8;
      user-select: none;
      box-sizing: border-box;
      touch-action: manipulation;
    }

    a.title {
      text-decoration: none;
    }

    #content-outer {
      margin: 4% 14%;
      padding: 4% 8%;
      border-radius: 5px;
      box-sizing: border-box;
    }

    #content-inner {
      width: 100%;
      overflow: hidden;
    }

    .recent-post-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      padding-bottom: 16px;
    }

    .recent-post-item .title {
      overflow: hidden;
      text-overflow:ellipsis;
      white-space: nowrap;
    }

    .recent-post-item .time {
      font-size: 14px;
      line-height: 32px;
      min-width: 81px;
      text-align: right;
    }

    #post img {
      max-width: 100%;
    }

    #post h1.title {
      text-align: center;
      font-size: 2em;
      margin-block-start: 0.67em;
      margin-block-end: 0.67em;
      line-height: 1;
    }

    #post .time {
      text-align: center;
      font-size: 14px;
    }

    #post .content {
      margin-top: 8%;
    }

    #post .content blockquote {
      padding-left: 20px;
      margin: 0;
    }

    #post .content .gutter {
      display: none;
    }

    code, kbd, pre, samp {
      font-size: 16px !important;
    }

    .CodeMirror {
      height: auto !important;
      padding: 36px 24px 0;
      border-radius: 6px;
    }

    #post .content figure {
      padding: 0 1em;
      margin: 0;
      overflow: auto;
    }

    #post .content figure table {
      width: 100%;
    }

    @media screen and (max-width: 1024px)  {
      #content-outer {
        margin: 2% 7%;
        padding: 2% 4%;
      }

      .recent-post-item:first-child {
        margin-top: 16px;
      }
    }

    @media screen and (max-width: 480px) {
      body{
        -webkit-text-size-adjust: none;
      }

      #content-outer {
        margin: 0;
        padding: 2% 4%;
        border-radius: 0;
      }

      .recent-post-item:first-child {
        margin-top: 32px;
      }

      .recent-post-item:last-child {
        border-bottom: none;
      }
    }
  </style>
  
    <!-- styles list from theme config.yml -->
    
      <link rel="stylesheet" href="/css/theme.css">
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.46.0/codemirror.min.css">
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.46.0/theme/seti.min.css">
    
  
<meta name="generator" content="Hexo 8.1.1"></head>
<body class="cm-s-seti">

<div id="content-outer">
  <div id="content-inner">
    
<article id="post">
  <h1 class="title">Fict â€“ A compiler that makes JavaScript variables automatically reactive</h1>
  <p class="time">2025-12-31</span>
  <div class="content">
      <p>Fict - <a href="https://github.com/fictjs/fict">https://github.com/fictjs/fict</a></p>
<h2 id="Opening-A-Starting-Point-for-Technical-Exploration"><a href="#Opening-A-Starting-Point-for-Technical-Exploration" class="headerlink" title="Opening: A Starting Point for Technical Exploration"></a>Opening: A Starting Point for Technical Exploration</h2><p>When developing with React, we often write code like this:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> doubled = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> count * <span class="number">2</span>, [count]);</span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="number">1</span>), []);</span><br></pre></td></tr></table></figure>

<p>The meaning expressed by these three lines is actually quite simple: <code>count</code> is a number, and <code>doubled</code> is twice its value.</p>
<p>This raises a question: <strong>Is it possible for a compiler to automatically infer these dependencies?</strong></p>
<p>Modern compilers are already capable of analyzing control flow, performing type inference, and eliminating dead codeâ€”theoretically, automatically tracking variable dependencies seems feasible as well.</p>
<p>Fict is a technical exploration based precisely on this idea.</p>
<hr>
<h2 id="Part-1-Core-Design-Philosophy"><a href="#Part-1-Core-Design-Philosophy" class="headerlink" title="Part 1: Core Design Philosophy"></a>Part 1: Core Design Philosophy</h2><h3 id="What-if-variables-justâ€¦-worked"><a href="#What-if-variables-justâ€¦-worked" class="headerlink" title="What if variables justâ€¦ worked?"></a>What if variables justâ€¦ worked?</h3><p>The core hypothesis of Fict is:</p>
<p><strong>If the compiler can see your code, it can know which variables depend on which other variables.</strong></p>
<p>Letâ€™s look at an example:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = $state(<span class="number">0</span>); <span class="comment">// Marker: This is mutable state (reactive source)</span></span><br><span class="line">  <span class="keyword">const</span> doubled = count * <span class="number">2</span>; <span class="comment">// Compiler inference: Depends on count</span></span><br><span class="line">  <span class="keyword">const</span> message = <span class="string">`Value: <span class="subst">$&#123;doubled&#125;</span>`</span>; <span class="comment">// Compiler inference: Depends on doubled â†’ Depends on count</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> count++&#125;&gt;&#123;message&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice what is <strong>missing</strong> here:</p>
<ul>
<li>No <code>setCount</code> (direct assignment)</li>
<li>No <code>useMemo</code> (automatic inference)</li>
<li>No dependency arrays (compiler analysis)</li>
<li>No <code>.value</code> or explicit getter calls (just plain variables)</li>
</ul>
<p><code>$state(0)</code> is the only marker. Everything else is inferred by the compiler itself.</p>
<h3 id="Technical-Feasibility-Analysis"><a href="#Technical-Feasibility-Analysis" class="headerlink" title="Technical Feasibility Analysis"></a>Technical Feasibility Analysis</h3><p>This isnâ€™t magic; itâ€™s based on mature static analysis technology.</p>
<p>The compiler constructs a High-Level Intermediate Representation (HIR, a high-level IR) and performs data flow analysis; with the right representation, dependency tracking turns into a â€œtraversing the dependency graphâ€ problem.</p>
<p>In a simplified SSA (Static Single Assignment) perspective, you would see a dependency chain like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count_1    = $state(0)                 // Reactive source</span><br><span class="line">doubled_1  = count_1 * 2               // Uses count_1 â†’ Depends on count</span><br><span class="line">message_1  = `Value: $&#123;doubled_1&#125;`     // Uses doubled_1 â†’ Transitive dependency on count</span><br></pre></td></tr></table></figure>

<p>The compiler knows <code>message</code> depends on <code>count</code> without you telling it.</p>
<blockquote>
<p>The above is an overview of Fictâ€™s core design philosophy and technical route. Subsequent chapters will detail the specific implementation methods.</p>
</blockquote>
<hr>
<h2 id="Part-2-Comparison-with-Other-Frameworks"><a href="#Part-2-Comparison-with-Other-Frameworks" class="headerlink" title="Part 2: Comparison with Other Frameworks"></a>Part 2: Comparison with Other Frameworks</h2><h3 id="2-1-Syntax-Comparison"><a href="#2-1-Syntax-Comparison" class="headerlink" title="2.1 Syntax Comparison"></a>2.1 Syntax Comparison</h3><p>Letâ€™s look at how different frameworks handle the same problem:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">â”‚ React                                                       â”‚</span><br><span class="line">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span><br><span class="line">â”‚ const [count, setCount] = useState(0)                       â”‚</span><br><span class="line">â”‚ const doubled = useMemo(() =&gt; count * 2, [count])           â”‚</span><br><span class="line">â”‚ // Problem: Manual dependency arrays are error-prone;       â”‚</span><br><span class="line">â”‚ // React Compiler automates memoization.                    â”‚</span><br><span class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line"></span><br><span class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">â”‚ Solid                                                       â”‚</span><br><span class="line">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span><br><span class="line">â”‚ const [count, setCount] = createSignal(0)                   â”‚</span><br><span class="line">â”‚ const doubled = createMemo(() =&gt; count() * 2)               â”‚</span><br><span class="line">â”‚ // Mental model: count vs count();                          â”‚</span><br><span class="line">â”‚ // Destructuring props might lose reactivity (use splitProps)â”‚</span><br><span class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line"></span><br><span class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">â”‚ Svelte 5                                                    â”‚</span><br><span class="line">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span><br><span class="line">â”‚ let count = $state(0)                                       â”‚</span><br><span class="line">â”‚ let doubled = $derived(count * 2)                           â”‚</span><br><span class="line">â”‚ // Better, but derived intent still needs explicit $derived â”‚</span><br><span class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line"></span><br><span class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">â”‚ Fict                                                        â”‚</span><br><span class="line">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span><br><span class="line">â”‚ let count = $state(0)                                       â”‚</span><br><span class="line">â”‚ const doubled = count * 2                                   â”‚</span><br><span class="line">â”‚ // No $derived: Compiler automatically infers within static â”‚</span><br><span class="line">â”‚ // analysis scope.                                          â”‚</span><br><span class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-Compiler-Comparison"><a href="#2-2-Compiler-Comparison" class="headerlink" title="2.2 Compiler Comparison"></a>2.2 Compiler Comparison</h3><p>Syntax is just the surface difference. A more essential distinction lies in: <strong>What responsibilities do the compilers (or runtimes) of each framework assume?</strong></p>
<hr>
<h4 id="React-Compiler-Automatic-Memoization-Does-not-change-React-Model"><a href="#React-Compiler-Automatic-Memoization-Does-not-change-React-Model" class="headerlink" title="React Compiler: Automatic Memoization (Does not change React Model)"></a>React Compiler: Automatic Memoization (Does not change React Model)</h4><p>The goal of React Compiler is clear: <strong>Automatic memoization</strong>.</p>
<p>Its output often â€œlooks likeâ€ it automatically added <code>React.memo / useMemo / useCallback</code> for you, but implementation-wise, it doesnâ€™t necessarily generate these Hook calls; in public discussions, React Compiler explicitly stated it directly inlines dependency checks and caches values, avoiding the overhead of closures and dependency arrays associated with handwritten <code>useMemo/useCallback</code>.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">&#123; items &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sorted = items.<span class="title function_">toSorted</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">List</span> <span class="attr">data</span>=<span class="string">&#123;sorted&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can understand the compilerâ€™s â€œconceptualâ€ output as:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Conceptual equivalent (for understanding, not necessarily actual output)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">&#123; items &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sorted = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> items.<span class="title function_">toSorted</span>(), [items]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">List</span> <span class="attr">data</span>=<span class="string">&#123;sorted&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>What it does:</strong></p>
<ul>
<li>âœ… Automatic memoization: Caches calculation results, stabilizes references, reduces unnecessary re-computations and re-renders.</li>
<li>âœ… Skips as many updates as possible without changing Reactâ€™s render + reconciliation model.</li>
<li>âœ… Still allows developers to use <code>useMemo/useCallback</code> as escape hatches (e.g., for stable effect dependencies).</li>
<li>âœ… Provides <code>&quot;use no memo&quot;</code> as a temporary escape hatch: lets a specific function completely skip compiler optimization for troubleshooting incompatible code.</li>
</ul>
<p><strong>What it doesnâ€™t do:</strong></p>
<ul>
<li>âŒ Does not turn React into a â€œcompile to fine-grained DOM instructionsâ€ framework: React is still render + reconciliation (colloquially â€œVDOM + diffâ€).</li>
<li>âŒ Does not replace the hooks system: You still write <code>useState/useEffect/...</code>. The compiler just tries to automate â€œcaching workâ€ like memoization.</li>
</ul>
<p>React Compilerâ€™s design positioning is: <strong>Improve performance through automatic memoization without changing the logical model of React</strong>.</p>
<hr>
<h4 id="Svelte-5-Template-Compilation-Explicit-Runes-Derivations-Side-Effects-capture-dependencies-at-evaluation"><a href="#Svelte-5-Template-Compilation-Explicit-Runes-Derivations-Side-Effects-capture-dependencies-at-evaluation" class="headerlink" title="Svelte 5: Template Compilation + Explicit Runes (Derivations&#x2F;Side Effects capture dependencies at evaluation)"></a>Svelte 5: Template Compilation + Explicit Runes (Derivations&#x2F;Side Effects capture dependencies at evaluation)</h4><p>Svelteâ€™s typical path is: <strong>Compile templates to DOM update code</strong> (no VDOM), and use runes (<code>$state/$derived/$effect</code>) to explicitly write out the intent of â€œthis is state&#x2F;derived&#x2F;side-effectâ€.</p>
<p>The key point: Svelte 5â€™s <code>$derived</code> documentation clearly states dependency rulesâ€”<strong>any value read synchronously inside a <code>$derived</code> expression (or <code>$derived.by</code> function body) becomes a dependency</strong>; when dependencies change, it is marked dirty and re-calculated on next read.<br><code>$effect</code> similarly drives re-execution based on dependency changes.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let count = $state(0)</span><br><span class="line">  let doubled = $derived(count * 2)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;button on:click=&#123;() =&gt; count++&#125;&gt;</span><br><span class="line">  &#123;doubled&#125;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><strong>What it does:</strong></p>
<ul>
<li>âœ… Template â†’ DOM update code (no VDOM)</li>
<li>âœ… Runes provide explicit semantics: <code>$derived</code> for derivations, <code>$effect</code> for side effects, dependencies captured at evaluation and schedule updates.</li>
</ul>
<p><strong>What it doesnâ€™t do:</strong></p>
<ul>
<li>âŒ Does not do global SSA-level automatic derivation inference for â€œarbitrary JS blocksâ€ to let you skip <code>$derived</code>: In Svelte, derivation intent still needs to be expressed via <code>$derived</code>.</li>
<li>âŒ UI components are still organized around <code>.svelte</code> files (this is its ecosystem &amp; DX choice).</li>
</ul>
<hr>
<h4 id="Solid-Compile-time-JSX-lowering-JSX-compilation-Runtime-Fine-grained-Dependency-Tracking-No-VDOM"><a href="#Solid-Compile-time-JSX-lowering-JSX-compilation-Runtime-Fine-grained-Dependency-Tracking-No-VDOM" class="headerlink" title="Solid: Compile-time JSX lowering &#x2F; JSX compilation + Runtime Fine-grained Dependency Tracking (No VDOM)"></a>Solid: Compile-time JSX lowering &#x2F; JSX compilation + Runtime Fine-grained Dependency Tracking (No VDOM)</h4><p>Solidâ€™s route is more like: <strong>Compiler is responsible for turning JSX into efficient DOM creation&#x2F;binding</strong>, while dependency tracking and update scheduling mainly happen at runtime (signals&#x2F;memos&#x2F;effects).</p>
<p>Solid official documentation clearly warns: <strong>Direct destructuring of props is not recommended</strong>, as it may break reactivity; need to use <code>props.xxx</code>, wrapper functions, or <code>splitProps</code>.<br>Meanwhile, Solidâ€™s homepage explicitly emphasizes: <strong>No Virtual DOM &#x2F; no extensive diffing</strong>, updates can be precise to the DOM binding layer.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">createSignal</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> doubled = <span class="title function_">createMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">count</span>() * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount((c) =&gt; c + 1)&#125;&gt;&#123;doubled()&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>What it does:</strong></p>
<ul>
<li><p>âœ… JSX â†’ DOM templates&#x2F;bindings (static optimization at compile time)</p>
</li>
<li><p>âœ… Runtime fine-grained dependency tracking: Whoever uses the signal subscribes to it; only updates relevant DOM bindings when changed (no VDOM).</p>
</li>
<li><p>âœ… Provides tools (like <code>splitProps</code>) to safely handle props (avoiding loss of reactivity on destructuring).<br><strong>What it doesnâ€™t do:</strong></p>
</li>
<li><p>âŒ No â€œautomatic derivation inferenceâ€: Derived values usually need explicit <code>createMemo</code>.</p>
</li>
<li><p>âŒ Runtime model is â€œsignals drivenâ€, not â€œcompiler globally infers everythingâ€.</p>
</li>
</ul>
<hr>
<h4 id="Vue-Vapor-A-â€œNo-VDOMâ€-Exploration-Direction-Still-Evolving"><a href="#Vue-Vapor-A-â€œNo-VDOMâ€-Exploration-Direction-Still-Evolving" class="headerlink" title="Vue Vapor: A â€œNo VDOMâ€ Exploration Direction (Still Evolving)"></a>Vue Vapor: A â€œNo VDOMâ€ Exploration Direction (Still Evolving)</h4><p>In Vueâ€™s official documentation, Vapor Mode is described as <strong>a new compilation strategy being explored</strong>: inspired by Solid, <strong>not relying on Virtual DOM</strong>, and making stricter use of Vueâ€™s built-in reactivity system.<br>Meanwhile, the <code>vue-vapor</code> repository itself is in an archived (read-only) state, so it should be treated as experimental &#x2F; in flux.</p>
<hr>
<h3 id="Compiler-Comparison-Table-Stricter-Version"><a href="#Compiler-Comparison-Table-Stricter-Version" class="headerlink" title="Compiler Comparison Table (Stricter Version)"></a>Compiler Comparison Table (Stricter Version)</h3><blockquote>
<p>Note: âœ… &#x3D; Officially clearly described and presented as a stable capability; ğŸ§ª &#x3D; Officially defined as exploration&#x2F;experimental direction; â€” &#x3D; Not the main narrative of the framework&#x2F;hard to draw a hard conclusion.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Dimension</th>
<th align="left">React + React Compiler</th>
<th align="left">Svelte 5</th>
<th align="left">Solid</th>
<th align="left">Vue Vapor</th>
<th align="left">Fict</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Automatic memoization (reduce manual memo)</td>
<td align="left">âœ… Automatic memoization, <code>useMemo/useCallback</code> as escape hatch; supports <code>&quot;use no memo&quot;</code> to skip optimization.</td>
<td align="left">âŒ Derivations need explicit <code>$derived</code>.</td>
<td align="left">âŒ Derivations usually need <code>createMemo</code> (explicit).</td>
<td align="left">â€”</td>
<td align="left">âœ…</td>
</tr>
<tr>
<td align="left">Still render + reconciliation?</td>
<td align="left">âœ… Yes.</td>
<td align="left">âŒ (Template compiled to DOM updates)</td>
<td align="left">âŒ (No VDOM&#x2F;No diffing)</td>
<td align="left">ğŸ§ª Official exploration of â€œNo VDOMâ€ strategy.</td>
<td align="left">âŒ</td>
</tr>
<tr>
<td align="left">Are Derived&#x2F;Side-effect intents explicit?</td>
<td align="left">âœ… Hooks explicit; memoization can be automated by compiler.</td>
<td align="left">âœ… <code>$derived/$effect</code> explicit; dependencies are captured from synchronous reads during evaluation.</td>
<td align="left">âœ… Explicit memo&#x2F;effect; dependency tracking at runtime.</td>
<td align="left">âœ… (Vue default: computed&#x2F;watch etc.; Vaporâ€™s commitment to not changing intent expression is not set in stone)</td>
<td align="left">âœ…</td>
</tr>
<tr>
<td align="left">DX Form</td>
<td align="left">JS&#x2F;JSX + Compiler</td>
<td align="left"><code>.svelte</code> + runes</td>
<td align="left">JS&#x2F;JSX + signals</td>
<td align="left">SFC&#x2F;Template-centric (Vapor is exploration)</td>
<td align="left">Pure JSX&#x2F;JS</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-3-Execution-Model-Comparison"><a href="#2-3-Execution-Model-Comparison" class="headerlink" title="2.3 Execution Model Comparison"></a>2.3 Execution Model Comparison</h2><p>The compiler is only half the story; the other half is the execution model.</p>
<table>
<thead>
<tr>
<th align="left">Framework</th>
<th align="left">Does Component Code Re-execute?</th>
<th align="left">Update Granularity</th>
<th align="left">Control Flow Expression</th>
</tr>
</thead>
<tbody><tr>
<td align="left">React (with Compiler)</td>
<td align="left">React still re-renders; the compiler memoizes values&#x2F;functions to reduce work and stabilize props.</td>
<td align="left">Component&#x2F;Subtree dominant (determined by reconciliation)</td>
<td align="left">Native JS (if&#x2F;for)</td>
</tr>
<tr>
<td align="left">Solid</td>
<td align="left">Executes once on init; subsequent fine-grained updates driven by signal subscriptions (no VDOM&#x2F;diff).</td>
<td align="left">DOM Binding Level</td>
<td align="left">Commonly uses <code>&lt;Show&gt;/&lt;For&gt;</code> control flow components</td>
</tr>
<tr>
<td align="left">Svelte 5</td>
<td align="left">Executes once on init; <code>$derived/$effect</code> scheduled on dependency change.</td>
<td align="left">DOM update code + runes scheduling</td>
<td align="left">Template blocks (<code>{#if}/{#each}</code>)</td>
</tr>
<tr>
<td align="left">Vue Vapor</td>
<td align="left">ğŸ§ª Exploring: Goal is rendering path not dependent on VDOM.</td>
<td align="left">ğŸ§ª</td>
<td align="left">Template&#x2F;Directives centric</td>
</tr>
<tr>
<td align="left">Fict</td>
<td align="left">On-demand (Mixed)</td>
<td align="left">Fine-grained DOM update</td>
<td align="left">Native JS (if&#x2F;for)</td>
</tr>
</tbody></table>
<h3 id="An-Intuitive-Example-Re-execution-Strategy-and-Slot-Reuse"><a href="#An-Intuitive-Example-Re-execution-Strategy-and-Slot-Reuse" class="headerlink" title="An Intuitive Example: Re-execution Strategy and Slot Reuse"></a>An Intuitive Example: Re-execution Strategy and Slot Reuse</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mount once&quot;</span>); <span class="comment">// First run</span></span><br><span class="line">  <span class="keyword">let</span> count = $state(<span class="number">0</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;re-run with&quot;</span>, count); <span class="comment">// Re-runs when count changes</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> count++&#125;&gt;&#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>After clicking the button, the console will only append <code>re-run with 1/2/...</code>. <code>mount once</code> will not repeat, indicating that only the region reading the state is re-executed. The compiler achieves this by hoisting static parts outside the reactive region, or splitting the function into multiple regions.</li>
<li>DOM will not be recreated: Signal slot reuse + binding updates ensure the button node, events, and refs remain in place, only the text node updates.</li>
</ul>
<hr>
<h2 id="Part-3-Fictâ€™s-â€œFull-Link-Analysisâ€-Design-Goal"><a href="#Part-3-Fictâ€™s-â€œFull-Link-Analysisâ€-Design-Goal" class="headerlink" title="Part 3: Fictâ€™s â€œFull-Link Analysisâ€ (Design Goal)"></a>Part 3: Fictâ€™s â€œFull-Link Analysisâ€ (Design Goal)</h2><p>One thing Fict attempts to do is: <strong>Analyze the entire JS function, not just the template part.</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = $state(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> doubled = count * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> message = <span class="string">`Value: <span class="subst">$&#123;doubled&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Special</span> <span class="attr">value</span>=<span class="string">&#123;message&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> count++&#125;&gt;&#123;message&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main processing stages of the Fict compiler:</p>
<ol>
<li><strong>Build HIR (High-Level Intermediate Representation)</strong>: Function body â†’ Basic Blocks + CFG (including if&#x2F;for&#x2F;while&#x2F;switch)</li>
<li><strong>Convert to SSA</strong>: Make assignment versions unique, facilitating explicit dependency edges</li>
<li><strong>Analyze Reactive Scopes</strong>: Automatically turn expression regions dependent on <code>$state</code> into memo&#x2F;effect&#x2F;bindings</li>
<li><strong>Detect Control Flow Reads</strong>: When reactive values appear in branch tests etc., choose paths that â€œneed re-executionâ€</li>
<li><strong>Generate Fine-grained DOM</strong>: JSX â†’ DOM instructions; Bindings â†’ Precise effects</li>
</ol>
<hr>
<h2 id="Part-4-Fictâ€™s-Mixed-Execution-Model"><a href="#Part-4-Fictâ€™s-Mixed-Execution-Model" class="headerlink" title="Part 4: Fictâ€™s Mixed Execution Model"></a>Part 4: Fictâ€™s Mixed Execution Model</h2><p>The execution model designed by Fict:</p>
<ul>
<li>If state is <strong>only read in JSX</strong> â†’ Component does not re-execute, only relevant DOM nodes update</li>
<li>If state is <strong>read in control flow</strong> (e.g., branch conditions in if&#x2F;switch&#x2F;loop) â†’ Component needs re-execution</li>
</ul>
<p>The compiler analyzes and decides which update strategy to adopt at compile time. Developers donâ€™t need to rewrite code into special syntax like <code>&lt;Show&gt;/&lt;For&gt;</code> or <code>{#if}</code>; native <code>if/for</code> works directly.</p>
<hr>
<h2 id="Part-5-How-the-Compiler-Works"><a href="#Part-5-How-the-Compiler-Works" class="headerlink" title="Part 5: How the Compiler Works"></a>Part 5: How the Compiler Works</h2><blockquote>
<p>The Fict compiler transforms source code into efficient runtime code through several core stages.</p>
</blockquote>
<h3 id="Inside-the-compiler"><a href="#Inside-the-compiler" class="headerlink" title="Inside the compiler"></a>Inside the compiler</h3><p>Fict compilerâ€™s core is a multi-stage pipeline:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Plain JS/TS + JSX/TSX (compiled)</span><br><span class="line">     â†“</span><br><span class="line">  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">  â”‚  HIR    â”‚  CFG (Basic Blocks + Control Flow Graph)</span><br><span class="line">  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜</span><br><span class="line">       â†“</span><br><span class="line">  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">  â”‚  SSA    â”‚  Versioned Assignments + Dependency Analysis</span><br><span class="line">  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜</span><br><span class="line">       â†“</span><br><span class="line">  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">  â”‚ Reactive Scopes â”‚  Reactive Scope Analysis + Region Grouping</span><br><span class="line">  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line">       â†“</span><br><span class="line">  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">  â”‚ Codegen â”‚  Fine-grained DOM Operations + bindings</span><br><span class="line">  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br></pre></td></tr></table></figure>

<p>The compiler performs <strong>Reactive Scope Analysis</strong> to determine memoization boundaries, automatically identifying which expressions should be wrapped as memos, and their dependencies.</p>
<h3 id="HIR-Construction-Schematic"><a href="#HIR-Construction-Schematic" class="headerlink" title="HIR Construction (Schematic)"></a>HIR Construction (Schematic)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Special</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Normal</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HIR (Schematic)</span></span><br><span class="line"><span class="title class_">Block</span> <span class="number">0</span>:</span><br><span class="line">  $0 = <span class="title class_">LoadLocal</span> count</span><br><span class="line">  $1 = <span class="title class_">BinaryExpr</span>(&gt;) $0, <span class="number">10</span></span><br><span class="line">  <span class="title class_">Branch</span> $1 -&gt; <span class="title class_">Block1</span>, <span class="title class_">Block2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Block</span> <span class="number">1</span>:</span><br><span class="line">  $2 = <span class="title class_">JSXElement</span>(<span class="title class_">Special</span>)</span><br><span class="line">  <span class="title class_">Return</span> $2</span><br><span class="line"></span><br><span class="line"><span class="title class_">Block</span> <span class="number">2</span>:</span><br><span class="line">  $3 = <span class="title class_">JSXElement</span>(<span class="title class_">Normal</span>)</span><br><span class="line">  <span class="title class_">Return</span> $3</span><br></pre></td></tr></table></figure>

<h3 id="SSA-Conversion-Dependency-Tracking-Schematic"><a href="#SSA-Conversion-Dependency-Tracking-Schematic" class="headerlink" title="SSA Conversion &amp; Dependency Tracking (Schematic)"></a>SSA Conversion &amp; Dependency Tracking (Schematic)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = count</span><br><span class="line"><span class="keyword">if</span> (cond) &#123;</span><br><span class="line">  x = count + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSA (Schematic)</span></span><br><span class="line">x_1 = count_1</span><br><span class="line"><span class="title class_">Branch</span> cond -&gt; <span class="title class_">Block1</span>, <span class="title class_">Block2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Block1</span>:</span><br><span class="line">  x_2 = count_1 + <span class="number">1</span></span><br><span class="line">  <span class="title class_">Jump</span> -&gt; <span class="title class_">Block3</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Block2</span>:</span><br><span class="line">  <span class="title class_">Jump</span> -&gt; <span class="title class_">Block3</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Block3</span>:</span><br><span class="line">  x_3 = <span class="title class_">Phi</span>(<span class="title class_">Block1</span>: x_2, <span class="title class_">Block2</span>: x_1)</span><br><span class="line">  <span class="title class_">Return</span> x_3</span><br></pre></td></tr></table></figure>

<p>Now the dependency relationship is very clear: <code>x_3</code> ultimately depends on <code>count_1</code>.</p>
<hr>
<h2 id="Part-6-Compilation-Output-Example-Simplified"><a href="#Part-6-Compilation-Output-Example-Simplified" class="headerlink" title="Part 6: Compilation Output Example (Simplified)"></a>Part 6: Compilation Output Example (Simplified)</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = $state(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> doubled = count * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> count++&#125;&gt;&#123;doubled&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output (Simplified Schematic)</span></span><br><span class="line"><span class="comment">// User code stays â€˜plain variablesâ€™; the generated code may use accessor calls internally.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> __ctx = <span class="title function_">__fictUseContext</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $state -&gt; signal</span></span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">__fictUseSignal</span>(__ctx, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Derived value -&gt; memo (Compiler inferred)</span></span><br><span class="line">  <span class="keyword">const</span> doubled = <span class="title function_">__fictUseMemo</span>(__ctx, <span class="function">() =&gt;</span> <span class="title function_">count</span>() * <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM Creation</span></span><br><span class="line">  <span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> text = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  button.<span class="title function_">appendChild</span>(text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Binding Update (Using fine-grained effect)</span></span><br><span class="line">  <span class="title function_">bindText</span>(text, <span class="function">() =&gt;</span> <span class="title function_">doubled</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Event</span></span><br><span class="line">  button.<span class="property">onclick</span> = <span class="function">() =&gt;</span> <span class="title function_">count</span>(<span class="title function_">count</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> button;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The characteristics of this compilation output are:</p>
<ul>
<li>No VDOM</li>
<li>No diffing</li>
<li>Only precise DOM operations</li>
<li><code>doubled</code> automatically memoized</li>
</ul>
<hr>
<h3 id="Example-with-Control-Flow"><a href="#Example-with-Control-Flow" class="headerlink" title="Example with Control Flow"></a>Example with Control Flow</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> show = $state(<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">if</span> (show) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Panel</span> /&gt;</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Fallback</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output (Simplified)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> __ctx = <span class="title function_">__fictUseContext</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">__fictRender</span>(__ctx, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> show = <span class="title function_">__fictUseSignal</span>(__ctx, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Control flow triggers re-execution, so the whole render function logic runs again</span></span><br><span class="line">    <span class="comment">// But signals are reused via slots, not recreated</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createConditional</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">show</span>(),</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="comment">/* Panel&#x27;s fine-grained DOM */</span>,</span><br><span class="line">      createElement,</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="comment">/* Fallback&#x27;s fine-grained DOM */</span></span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__fictRender</code> re-executes the internal function when <code>show</code> changes, but <code>__fictUseSignal</code> reuses state via slots, so state is not lost.</p>
<h3 id="Reactivity-of-Props"><a href="#Reactivity-of-Props" class="headerlink" title="Reactivity of Props"></a>Reactivity of Props</h3><p>Fict automatically maintains the reactivity of props, even after destructuring:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">&#123; count, update &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> doubled = count * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;doubled&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output (Simplified)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">__props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> __ctx = <span class="title function_">__fictUseContext</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Destructured props automatically wrapped as getters</span></span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useProp</span>(<span class="function">() =&gt;</span> __props.<span class="property">count</span>);</span><br><span class="line">  <span class="keyword">const</span> update = __props.<span class="property">update</span>; <span class="comment">// Function type not wrapped</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Derived values automatically become memos</span></span><br><span class="line">  <span class="keyword">const</span> doubled = <span class="title function_">__fictUseMemo</span>(__ctx, <span class="function">() =&gt;</span> <span class="title function_">count</span>() * <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This solves a common pain point in Solid: Destructuring props breaks reactivity. In Fict, you can destructure freely.</p>
<hr>
<h2 id="Part-7-Compiler-Safety-Rails"><a href="#Part-7-Compiler-Safety-Rails" class="headerlink" title="Part 7: Compiler Safety Rails"></a>Part 7: Compiler Safety Rails</h2><h3 id="DX-Protection-Mechanisms"><a href="#DX-Protection-Mechanisms" class="headerlink" title="DX Protection Mechanisms"></a>DX Protection Mechanisms</h3><p>The Fict compiler detects common error patterns and issues warnings:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">â”‚ Code       â”‚ Issue                   â”‚ Severity             â”‚</span><br><span class="line">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span><br><span class="line">â”‚ FICT-C003  â”‚ Nested Component Def    â”‚ Warning              â”‚</span><br><span class="line">â”‚ FICT-M003  â”‚ Memo with Side Effects  â”‚ Warning              â”‚</span><br><span class="line">â”‚ FICT-S002  â”‚ State passed as arg     â”‚ Warning              â”‚</span><br><span class="line">â”‚ FICT-J002  â”‚ List missing key        â”‚ Warning              â”‚</span><br><span class="line">â”‚ FICT-E001  â”‚ Effect no deps          â”‚ Warning              â”‚</span><br><span class="line">â”‚ FICT-C004  â”‚ Component no return     â”‚ Warning              â”‚</span><br><span class="line">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span><br><span class="line">â”‚ $state inside condition | Not Allowed | Compile Error       â”‚</span><br><span class="line">â”‚ $state inside loop      | Not Allowed | Compile Error       â”‚</span><br><span class="line">â”‚ Destructuring $state    | Not Allowed | Compile Error       â”‚</span><br><span class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br></pre></td></tr></table></figure>

<p>For example, defining nested components is a common anti-pattern:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// âš ï¸ FICT-C003: Components should not be defined inside another component</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The compiler will warn you to move <code>Child</code> to module scope.</p>
<hr>
<h2 id="Part-8-Trade-offs"><a href="#Part-8-Trade-offs" class="headerlink" title="Part 8: Trade-offs"></a>Part 8: Trade-offs</h2><h3 id="What-Fict-canâ€™t-do-yet"><a href="#What-Fict-canâ€™t-do-yet" class="headerlink" title="What Fict canâ€™t do (yet)"></a>What Fict canâ€™t do (yet)</h3><p>I want to be honest about Fictâ€™s limitations:</p>
<p><strong>1. Dependency tracking inside black-box functions may be incomplete</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = someExternalLib.<span class="title function_">compute</span>(<span class="function">() =&gt;</span> count);</span><br><span class="line"><span class="comment">// Compiler cannot see inside compute callback, dependency tracking might be incomplete</span></span><br></pre></td></tr></table></figure>

<p>Solution: The compiler issues a warning (FICT-S002), you can use explicit getters or let the component take the re-execution path.</p>
<p><strong>2. Dynamic property access is limited</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="title function_">getDynamicKey</span>();</span><br><span class="line"><span class="keyword">const</span> value = obj[key]; <span class="comment">// Compiler doesn&#x27;t know what key is</span></span><br></pre></td></tr></table></figure>

<p>Solution: Degrade to object-level subscription + warning.</p>
<p><strong>3. No Ecosystem</strong></p>
<p>This is common for new frameworks. No UI library, no complete SSR framework, no mature router. If you need to go to production today, Fict might not be the right choice.</p>
<p><strong>4. Execution Model needs learning</strong></p>
<p>Fictâ€™s execution model differs from React (see Section 2.3):</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A&quot;</span>); <span class="comment">// Executes once</span></span><br><span class="line"><span class="keyword">let</span> count = $state(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;B&quot;</span>, count); <span class="comment">// Executes every time count changes</span></span><br></pre></td></tr></table></figure>

<p>Developers from a React background might be confused: â€œWhy doesnâ€™t A execute every time?â€ This requires understanding Fictâ€™s concept of reactive regions.</p>
<p>We will provide Fict DevTools to visualize these regions to aid debugging.</p>
<p><strong>5. Compiler Complexity</strong></p>
<p>Fictâ€™s compiler is much more complex than Solidâ€™s. More code means more potential bugs.</p>
<h3 id="Known-Escape-Hatches-Mitigation"><a href="#Known-Escape-Hatches-Mitigation" class="headerlink" title="Known Escape Hatches &#x2F; Mitigation"></a>Known Escape Hatches &#x2F; Mitigation</h3><ul>
<li>Explicit <code>$memo</code> &#x2F; <code>$effect</code>: When automatic inference doesnâ€™t meet expectations, manually declare derivation or side-effect boundaries.</li>
<li><code>useProp/mergeProps</code> helpers: Manually maintain reactivity when props access patterns are special.</li>
<li>Control Flow Degradation: Scenarios that cannot be statically analyzed are handed over to the re-execution model, prioritizing correctness.</li>
</ul>
<h3 id="Why-I-still-think-itâ€™s-worth-it"><a href="#Why-I-still-think-itâ€™s-worth-it" class="headerlink" title="Why I still think itâ€™s worth it"></a>Why I still think itâ€™s worth it</h3><p>Despite all these trade-offs, I believe what we get in return is worth it:</p>
<ul>
<li>The amount of code developers write every day is reduced.</li>
<li>Mental burden is reduced.</li>
<li>Beginners donâ€™t need to understand â€œwhy do I have to write useMemoâ€.</li>
</ul>
<p>React Compiler proved that â€œletting the compiler take more responsibilityâ€ is the right direction. Fict just pushes this idea a bit further.</p>
<hr>
<h2 id="Part-9-Extended-APIs"><a href="#Part-9-Extended-APIs" class="headerlink" title="Part 9: Extended APIs"></a>Part 9: Extended APIs</h2><p>Fict also provides some extended APIs to handle scenarios that automatic inference cannot cover:</p>
<ul>
<li><strong><code>$store</code></strong>: For fine-grained reactivity of nested objects. <code>$store</code> is the recommended choice when path-level update tracking for deep objects is needed.</li>
<li><strong><code>$memo</code></strong>: Escape hatch for explicitly creating memos. Although the compiler automatically infers derived values, developers can also manually control memoization.</li>
<li><strong><code>$effect</code></strong>: Explicitly declare side effects.</li>
<li><strong>ErrorBoundary &#x2F; Suspense &#x2F; Transitions</strong>: For error handling, async loading, and priority scheduling.</li>
</ul>
<blockquote>
<p>Fictâ€™s design philosophy is â€œreduce boilerplate + compiler automatic inferenceâ€, these APIs serve as supplementary tools for advanced scenarios.</p>
</blockquote>
<hr>
<h2 id="Part-10-Why-Now"><a href="#Part-10-Why-Now" class="headerlink" title="Part 10: Why Now"></a>Part 10: Why Now</h2><p>The frontend framework field is undergoing some interesting changes:</p>
<ol>
<li><strong>React Compiler achieved automatic memoization</strong>: Reduces the need for manual memo without changing the React model.</li>
<li><strong>Signals proposal is advancing in TC39</strong>: Although still in early stages, it reflects the communityâ€™s focus on reactive primitives.</li>
<li><strong>Svelte 5 makes derivation&#x2F;side-effect intent more explicit via runes</strong>, with clear dependency rules (sync read equals dependency).</li>
<li><strong>Vue is officially exploring Vapor Mode</strong>: A compilation strategy that doesnâ€™t rely on VDOM and utilizes built-in reactivity more.</li>
</ol>
<p>In this context:</p>
<blockquote>
<p>Fict does not attempt to replace these excellent frameworks, but is a technical exploration: If we start from scratch based on these excellent frameworks, taking â€œcompiler automatic dependency inferenceâ€ as the core design principle, how far can we go?</p>
</blockquote>
<hr>
<h2 id="Conclusion-Welcome-to-Try"><a href="#Conclusion-Welcome-to-Try" class="headerlink" title="Conclusion: Welcome to Try"></a>Conclusion: Welcome to Try</h2><p>Fict is currently under active development.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install fict</span><br></pre></td></tr></table></figure>

<p>The core compiler and runtime functions are basically stable, but the ecosystem is still under construction. If you are interested in trying it out, we look forward to your feedback:</p>
<ul>
<li>Bug reports (edge cases are especially valuable)</li>
<li>Suggestions for improving compiler output</li>
<li>Usage patterns you think should be supported but are not yet</li>
</ul>
<p>Thank you for reading, and looking forward to communicating with you.</p>

  </div>
</article>

  </div>
</div>


  <!-- scripts list from theme config.yml -->
  
    <script src="/js/attraction.js"></script>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.46.0/codemirror.min.js"></script>
  
  <script>
    var nodes = Array.from(document.querySelectorAll('pre code'));
    var render = {};
    var titleSvg = '<svg style="position: absolute;z-index: 1;margin: 12px 0 0 12px;" xmlns="http://www.w3.org/2000/svg" width="54" height="14" viewBox="0 0 54 14"><g fill="none" fill-rule="evenodd" transform="translate(1 1)"><circle cx="6" cy="6" r="6" fill="#FF5F56" stroke="#E0443E" stroke-width=".5"></circle><circle cx="26" cy="6" r="6" fill="#FFBD2E" stroke="#DEA123" stroke-width=".5"></circle><circle cx="46" cy="6" r="6" fill="#27C93F" stroke="#1AAB29" stroke-width=".5"></circle></g></svg>';
    nodes.forEach((node, index) => {
      var lang = node.getAttribute('class');
      var code = node.innerText;
      var mode = lang;
      switch(lang) {
        case 'jsx':
          lang = 'javascript';
          mode = 'text/jsx';
          break;
        case 'tsx':
          lang = 'javascript';
          mode = 'text/typescript-jsx';
        case 'typescript':
          lang = 'javascript';
          mode = 'text/typescript';
        default:
          break;
      }
      var config = {
        value: code,
        mode,
        theme: 'seti'
      };
      if (!lang) return;
      var hasExisted = nodes.slice(0, index).find(function(node) { return node.getAttribute('class') === lang; });
      if (hasExisted) {
        render[lang].push(function() {
          node.innerHTML = titleSvg;
          CodeMirror(node, config);
        });
        return;
      }
      render[lang] = [];
      var languagePackge = document.createElement('script');
      languagePackge.src = `https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.46.0/mode/${lang}/${lang}.min.js`;
      languagePackge.onload = () => {
        setTimeout(() => {
          node.innerHTML = titleSvg;
          CodeMirror(node, config);
          render[lang].forEach(function(callback) { callback(); })
        }, 0);
      }
      document.body.appendChild(languagePackge);
    });
  </script>

</body>
</html>
